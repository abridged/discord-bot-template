# ERC-7702: Account Abstraction Via Alternative Mempool

*Date: June 7, 2025*

## Standard Overview

ERC-7702 provides a standardized way to enable account abstraction features for Externally Owned Accounts (EOAs) through an alternative mempool system. This allows traditional EOA wallets to benefit from account abstraction capabilities without requiring a smart contract wallet.

## Key Components

### 1. UserOperation Structure

```javascript
struct UserOperation {
    address sender;           // EOA wallet address
    uint256 nonce;            // Unique operation identifier
    bytes initCode;           // For account initialization (usually empty for EOAs)
    bytes callData;           // The actual operation data
    uint256 callGasLimit;     // Gas limit for the call
    uint256 verificationGasLimit; // Gas for signature verification
    uint256 preVerificationGas;   // Gas paid to bundler
    uint256 maxFeePerGas;     // Similar to EIP-1559 maxFeePerGas
    uint256 maxPriorityFeePerGas; // Similar to EIP-1559
    bytes signature;          // EOA signature of the operation
}
```

### 2. Bundler Network

Specialized entities that collect signed UserOperations and package them into Ethereum transactions:

```javascript
class Bundler {
    constructor(provider, bundlerPrivateKey) {
        this.provider = provider;
        this.wallet = new ethers.Wallet(bundlerPrivateKey, provider);
        this.pendingOps = [];
    }

    async addUserOp(userOp) {
        // Validate user operation
        const valid = await this.validateUserOp(userOp);
        if (valid) {
            this.pendingOps.push(userOp);
        }
    }

    async bundleAndSend() {
        // Package user operations into transaction
        const bundledCalldata = this.createBundleCalldata(this.pendingOps);
        
        // Send transaction
        const tx = await this.wallet.sendTransaction({
            to: ERC7702_HANDLER_ADDRESS,
            data: bundledCalldata,
            gasLimit: this.calculateGasLimit(this.pendingOps)
        });
        
        return tx.hash;
    }
}
```

### 3. ERC-7702 Handler Contract

Contract responsible for processing UserOperations submitted by bundlers:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IERC7702Handler {
    function handleUserOperations(
        UserOperation[] calldata userOps
    ) external returns (bool);
}

contract ERC7702Handler is IERC7702Handler {
    // Process a batch of user operations
    function handleUserOperations(
        UserOperation[] calldata userOps
    ) external override returns (bool) {
        for (uint i = 0; i < userOps.length; i++) {
            _handleUserOperation(userOps[i]);
        }
        return true;
    }
    
    // Process a single user operation
    function _handleUserOperation(
        UserOperation calldata userOp
    ) internal returns (bool) {
        // 1. Verify signature
        address signer = _recoverSigner(userOp);
        require(signer == userOp.sender, "Invalid signature");
        
        // 2. Verify nonce
        _validateAndUpdateNonce(userOp.sender, userOp.nonce);
        
        // 3. Execute operation
        (bool success,) = userOp.sender.call{gas: userOp.callGasLimit}(userOp.callData);
        
        // 4. Emit event
        emit UserOperationExecuted(userOp.sender, success);
        
        return success;
    }
}
```

## Implementation Guide for Discord Bot Integration

### 1. Client-Side SDK Implementation

```javascript
class ERC7702Client {
    constructor(bundlerUrl, handlerAddress) {
        this.bundlerUrl = bundlerUrl;
        this.handlerAddress = handlerAddress;
    }
    
    // Create UserOperation for EOA wallet
    async createUserOperation(params) {
        const {
            sender,           // EOA address
            callData,         // Operation to execute
            nonce = null,     // Optional, will fetch if not provided
            gasParameters = {} // Optional gas parameters
        } = params;
        
        // Get nonce if not provided
        const currentNonce = nonce || await this.getUserNonce(sender);
        
        // Calculate gas parameters
        const callGasLimit = gasParameters.callGasLimit || 
            await this.estimateCallGas(callData);
            
        // Create UserOperation object
        const userOp = {
            sender,
            nonce: currentNonce,
            initCode: '0x',  // Empty for existing EOAs
            callData,
            callGasLimit,
            verificationGasLimit: gasParameters.verificationGasLimit || 100000,
            preVerificationGas: gasParameters.preVerificationGas || 50000,
            maxFeePerGas: gasParameters.maxFeePerGas || 
                await this.getMaxFeePerGas(),
            maxPriorityFeePerGas: gasParameters.maxPriorityFeePerGas || 
                await this.getMaxPriorityFeePerGas(),
            signature: '0x' // To be filled later
        };
        
        return userOp;
    }
    
    // Sign UserOperation with EOA private key
    async signUserOp(userOp, privateKey) {
        const userOpHash = this.getUserOpHash(userOp);
        
        // Sign the hash
        const wallet = new ethers.Wallet(privateKey);
        const signature = await wallet.signMessage(
            ethers.utils.arrayify(userOpHash)
        );
        
        // Return signed operation
        return {
            ...userOp,
            signature
        };
    }
    
    // Submit UserOperation to bundler
    async submitUserOperation(signedUserOp) {
        const response = await fetch(this.bundlerUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'eth_sendUserOperation',
                params: [signedUserOp, this.handlerAddress],
                id: Date.now()
            })
        });
        
        const result = await response.json();
        return result.result; // userOpHash
    }
    
    // Helper methods
    async getUserNonce(address) {
        // Call handler contract to get user nonce
    }
    
    async estimateCallGas(callData) {
        // Estimate gas for the call
    }
    
    getUserOpHash(userOp) {
        // Calculate hash according to ERC-7702
        return ethers.utils.keccak256(
            ethers.utils.defaultAbiCoder.encode(
                [
                    'address', 'uint256', 'bytes', 'bytes', 
                    'uint256', 'uint256', 'uint256',
                    'uint256', 'uint256'
                ],
                [
                    userOp.sender, userOp.nonce, userOp.initCode, userOp.callData,
                    userOp.callGasLimit, userOp.verificationGasLimit, 
                    userOp.preVerificationGas, userOp.maxFeePerGas,
                    userOp.maxPriorityFeePerGas
                ]
            )
        );
    }
    
    async getMaxFeePerGas() {
        // Get current gas price and add buffer
    }
    
    async getMaxPriorityFeePerGas() {
        // Get current priority fee
    }
}
```

### 2. Server-Side Handler Implementation

```javascript
// Discord bot backend service
class ERC7702Service {
    constructor(provider, erc7702Client) {
        this.provider = provider;
        this.erc7702Client = erc7702Client;
    }
    
    async processUserRequest(userId, walletAddress, operation) {
        try {
            // Create calldata for the operation
            const callData = this.encodeOperation(operation);
            
            // Create UserOperation
            const userOp = await this.erc7702Client.createUserOperation({
                sender: walletAddress,
                callData
            });
            
            // Return unsigned operation for client-side signing
            return {
                userOp,
                userOpHash: this.erc7702Client.getUserOpHash(userOp)
            };
        } catch (error) {
            console.error('Error creating user operation:', error);
            throw error;
        }
    }
    
    encodeOperation(operation) {
        // Encode operation based on type
        switch (operation.type) {
            case 'TOKEN_TRANSFER':
                return this.encodeTokenTransfer(operation);
            case 'CONTRACT_INTERACTION':
                return this.encodeContractCall(operation);
            // Other operation types...
            default:
                throw new Error('Unknown operation type');
        }
    }
    
    // Helper methods for encoding specific operations...
}
```

### 3. Discord Bot Command Handler Integration

```javascript
// Example command handler for token transfers
async function handleTokenTransfer(interaction) {
    try {
        // Extract parameters from command
        const recipient = interaction.options.getString('recipient');
        const amount = interaction.options.getString('amount');
        const tokenAddress = interaction.options.getString('token');
        
        // Get user wallet address from database
        const userWalletAddress = await getUserWallet(interaction.user.id);
        
        // If user has no wallet connected, prompt connection
        if (!userWalletAddress) {
            return await interaction.reply({
                content: 'Please connect your wallet first using /connect-wallet',
                ephemeral: true
            });
        }
        
        // Create operation
        const operation = {
            type: 'TOKEN_TRANSFER',
            tokenAddress,
            recipient,
            amount: ethers.utils.parseUnits(amount, 18) // Assuming 18 decimals
        };
        
        // Get UserOperation
        const erc7702Service = new ERC7702Service(provider, erc7702Client);
        const { userOp, userOpHash } = await erc7702Service.processUserRequest(
            interaction.user.id,
            userWalletAddress,
            operation
        );
        
        // Store UserOperation in database for later signature
        await storeUserOperation(interaction.user.id, userOp);
        
        // Send signing request to user
        await interaction.reply({
            content: `Please sign the transaction in your wallet to transfer ${amount} tokens to ${recipient}`,
            ephemeral: true,
            components: [
                new ActionRowBuilder().addComponents(
                    new ButtonBuilder()
                        .setCustomId('sign_tx')
                        .setLabel('Open Wallet')
                        .setStyle('PRIMARY')
                )
            ]
        });
        
        // Wait for user to sign
        const filter = i => i.customId === 'sign_tx' && i.user.id === interaction.user.id;
        const collector = interaction.channel.createMessageComponentCollector({
            filter,
            time: 60000
        });
        
        collector.on('collect', async i => {
            // Redirect to signing UI or provide signing instructions
            await i.update({
                content: 'Please sign the transaction in your wallet. Once signed, the transaction will be processed.',
                components: []
            });
            
            // In a real implementation, you would wait for the signature
            // from a client-side application or wallet connection
        });
    } catch (error) {
        console.error('Error processing token transfer:', error);
        await interaction.reply({
            content: 'An error occurred while processing your request',
            ephemeral: true
        });
    }
}
```

## Benefits for Discord Bot Users

1. **Simplicity** 
   - Users can continue using their existing EOA wallets
   - No need to deploy or manage smart contract wallets

2. **Lower Costs**
   - Reduced gas costs through bundling multiple operations
   - Option for third parties (like Discord bot operator) to subsidize gas

3. **Enhanced UX**
   - Operations can be prepared, signed, and executed asynchronously
   - Better error handling and retry mechanisms
   - Conditional execution based on on-chain state

4. **Gasless Transactions**
   - Users can perform actions without holding ETH for gas
   - Bundlers can cover gas costs and implement various business models

## Technical Considerations

1. **Security**
   - Proper nonce management to prevent replay attacks
   - Robust signature verification
   - Gas limit calculations to prevent DoS attacks

2. **Infrastructure**
   - Need for reliable bundler network
   - Monitoring for submitted operations
   - Fallback mechanisms for failed operations

3. **Limitations**
   - Less flexibility compared to full smart contract wallets
   - Reliance on bundler network availability
   - Some operations may still require direct EOA transactions

## Future Extensions

1. **Paymaster Integration**
   - Allow third parties to pay for user gas costs
   - Token-based gas payment models

2. **Batched Operations**
   - Enable users to sign multiple operations at once
   - Cross-contract atomic operations

3. **Conditional Execution**
   - Time-based conditions (execute after/before timestamp)
   - State-based conditions (execute if contract state matches criteria)

4. **Recovery Mechanisms**
   - Social recovery options for EOAs
   - Timelocks and limits for enhanced security

By implementing ERC-7702, Discord bots can provide a much better user experience for EOA wallet holders, allowing them to benefit from many account abstraction features without requiring them to switch to smart contract wallets.
