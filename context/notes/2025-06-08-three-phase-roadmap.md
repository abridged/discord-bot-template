MOA Bot Upgrade Roadmap: From Escrow Contracts to Delegated Execution and Wallet Intents

Phase 1 – Current Architecture with Upgrade-Ready Design (Factory + Escrows)

Factory & Per-Poll Escrows: In v1, the MOA bot deploys a distinct escrow smart contract for each poll or quiz via a factory. This isolates funds and logic per poll, but we can design it to be upgrade-friendly. One best practice is to use minimal proxy contracts (EIP-1167 clones) for each new poll’s escrow. Clones delegate calls to a shared implementation contract, reducing deployment cost while keeping state isolated in each clone ￼. By using a common escrow logic contract, any improvements can be applied for new polls by updating the factory to point to a new implementation. Each clone would be initialized with poll-specific parameters (using an initializer function instead of a constructor), allowing unique settings per poll while reusing the code template ￼ ￼.

Upgradeability Considerations: Minimal proxies themselves are immutable (their logic address is baked into bytecode, meaning an individual clone cannot be repointed to new logic after creation) ￼. However, this approach still facilitates upgrades by separating logic from data: we can deploy upgraded escrow logic for future polls without redeploying the entire system. Optionally, for critical long-running polls that might need in-place fixes, a more complex pattern like UUPS or Transparent upgradeable proxies per escrow could be employed – though this introduces admin keys and complexity. In summary, using a factory + minimal proxies gives a lightweight v1, and by planning storage layouts carefully now, we ensure new logic versions remain compatible. This lays the groundwork for seamless iteration as we evolve the MOA bot’s capabilities.

Event Emissions for Tracking: From day one, v1’s contracts should emit comprehensive events to aid future migration and indexing. For example, the factory can emit a PollCreated(pollId, escrowAddress, ...metadata) event whenever a new escrow is deployed. Similarly, escrow contracts can emit events like VoteCommitted(pollId, user, option) or PollFinalized(pollId, result). These events will allow off-chain indexers (The Graph or similar) to track all polls and user actions in a unified way. By using a consistent pollId or GUID in events, we create an audit trail that v2 can consume – for instance, a migration script or backend can map each v1 poll to any new v2 representation. Designing v1 with this transparency ensures we don’t lose history or context when upgrading. It also means the v1 -> v2 transition can be monitored (e.g. knowing which polls are still active in v1) and even automated since all necessary data (addresses, participants, outcomes) is logged on-chain.

Phase 2 – Transition to Delegated Execution (ERC-7710 Compliance)

Smart Accounts for Users: In v2, the architecture shifts from poll-centric contracts to user-centric smart accounts. Each user will have their own Delegator smart contract account (a lightweight contract wallet controlled by the user’s keys). According to the ERC-7710 standard, a Delegator is a smart contract that implements delegated actions on the user’s behalf (it implements the ERC7710 interface, extending ERC-1271 for signature validation) ￼. This means the user’s account can verify signatures and execute predetermined actions when authorized. We will deploy or register a Delegator for each active user (potentially on first use), which serves as their on-chain identity for MOA bot interactions in v2.

Delegation Manager for Gasless TX: Alongside user Delegators, we introduce a singleton Delegation Manager contract compliant with ERC7710Manager. The Delegation Manager’s role is to orchestrate gasless transactions: it is the only contract allowed to call executeDelegatedAction on a Delegator ￼ ￼. The flow will be as follows: when a user initiates a poll action via the MOA Discord bot, the bot (through Collab.Land’s interface) prompts the user to sign a delegation – essentially a message authorizing a specific action. The MOA bot (or a relayer service) then calls redeemDelegation on the Delegation Manager, passing in the user’s signed payload and the desired Action (e.g. “vote on poll X with option Y”) ￼. The Manager contract will validate the signature against the user’s Delegator (using ERC-1271 verification) and, if valid, call the user’s Delegator to actually perform the action on-chain ￼ ￼. The Delegator contract, upon receiving this call, checks that it indeed originated from the trusted Manager, then executes the call to the target poll/quiz function (using a low-level call, so the Delegator can interact with any contract as instructed) ￼. In summary, the user’s smart account remains in full control (nothing happens without their signed approval), but all transactions are “gasless” for the user – a relayer (possibly run by the MOA service or Collab.Land) covers the gas by actually submitting the Manager’s transaction.

Integration with Collab.Land Account Kit: We will leverage Collab.Land’s MetaMask Delegation Toolkit integration to streamline this process. Collab.Land’s Account Kit already works with MetaMask’s delegation features to enable partial account access and bot-initiated transactions in a Discord context ￼. Practically, this means when a user interacts with the MOA bot, Collab.Land’s UI will help request the necessary signature (perhaps via MetaMask pop-up or wallet connect) and then use the Delegation Manager contract to execute it. For the user, it feels like a normal confirmation (or even a simple click, if pre-authorized), and the blockchain sees a delegated call. By aligning with ERC-7710, we ensure our system is compatible with emerging tooling – MetaMask’s Delegation Toolkit and Collab.Land’s APIs will recognize the standard interfaces, simplifying integration. The Delegation Manager can be a custom contract in our system or Collab.Land’s provided one, but either way it conforms to ERC7710Manager so that any wallet supporting the standard can interact.

Poll Logic in v2: With user Delegators in play, we can refactor how poll logic is handled. One option is to retain a similar escrow contract per poll, but adapt it to the delegation flow. For instance, a v2 poll contract might not need to hold ETH for gas; instead, it simply has functions for voting or claiming that now expect calls from Delegator contracts. Another approach is to consolidate logic in the Delegators or a central manager: since each Delegator can hold tokens and execute code, users might lock their participation stake in their own smart account and just signal it via an event or a central registry. However, to minimize disruption, we likely keep a familiar pattern – e.g. a Poll contract that tallies votes or holds quiz rewards – but calls to it are made by Delegators on users’ behalf rather than EOAs. The important change is who initiates transactions: previously an EOA user directly called the escrow; in v2 the user’s Delegator calls the poll contract (triggered by the Delegation Manager after signature verification). This maintains the poll’s core logic but fits it into a gasless meta-tx paradigm.

Design for Indexing & Migration: During this phase, we ensure continuity of data. We will use events to link a user’s old EOA and new Delegator address (for example, an event DelegatorCreated(userEOA, delegatorAddress) on deployment of each smart account). This helps indexers or our backend map legacy participation to the new accounts. Additionally, poll events in v2 can carry the same pollId as in v1, so analytics and front-ends can unify results. By maintaining consistent identifiers and emitting events whenever a delegation-based action occurs (e.g., VoteCastDelegated(pollId, delegator, option)), we make sure the off-chain tracking systems see a seamless extension of the existing data instead of an abrupt break.

Phase 2b – Backward Compatibility and Bridging Strategies

Upgrading to the new delegation framework raises the question: What happens to the polls and escrows from v1? We propose a few strategies to ensure backward compatibility:
	•	Gradual Sunsetting of v1 Escrows: The simplest approach is to allow v1 poll contracts to continue operating until their conclusion, while all new polls use the v2 system. Users would finish any in-flight polls on the old system (perhaps using their EOAs as before), and all upcoming polls/quizzes would be created under the new delegation architecture. This parallel period requires our front-end/Discord bot to handle two flows (regular tx for old polls vs. delegated tx for new polls), but it avoids any complex migration of funds mid-poll. We will clearly label which polls are “v1” vs “v2” and provide instructions accordingly during the transition.
	•	Delegator Interoperability: For cases where we want users to interact with v1 escrows through the new v2 accounts, we can enable Delegators to call v1 escrow functions. Since a Delegator is just a smart contract wallet, it can technically call the old escrow’s methods (e.g., to vote or claim rewards) as long as the escrow does not forbid contract callers. If the v1 contracts were designed to only allow EOAs (e.g., checking tx.origin or similar, which is generally discouraged), we might need an update – but assuming they didn’t restrict that, a Delegator calling would be seen as just another address. The caveat is identity: a v1 poll might record the caller’s address as the participant. If a Delegator calls on behalf of a user, the poll contract would see the Delegator’s address, not the original EOA. To mitigate identity confusion, we could (if feasible) patch v1 escrows to recognize a mapping of Delegator-to-user or accept a signed attestation of the user. However, modifying many deployed contracts is impractical unless they were proxies. So, in most cases, using Delegators to directly interact with v1 polls would effectively treat the Delegator as a new participant. We will likely avoid this for voting (to preserve consistency), but we may use it for claiming rewards: e.g., a Delegator could claim a token reward from a v1 escrow, and since the reward is usually transferred to a specified recipient, the user’s Delegator can then forward it to the user’s new account.
	•	Upgrading v1 Contracts In-Place: If the v1 escrow clones had upgrade hooks (for example, if we had used OpenZeppelin upgradeable proxies instead of fixed minimal clones), we could deploy new logic that makes them delegation-aware. For instance, an upgraded poll contract might add a function delegateVote(address user, uint choice) callable by the Delegation Manager. Given our v1 uses minimal proxies (immutable logic) ￼, true in-place upgrades aren’t possible. Another creative approach could be deploying an adapter contract for each v1 escrow (or a single adapter for all), which the Delegator could call to interact with the escrow. This adapter, controlled by the user, might hold the user’s intention and then internally call the old escrow as the user. Yet, implementing this securely might be complex and not worth the effort for short-lived poll contracts.
	•	Data Migration: For any persistent data that must carry over (for example, if MOA bot had a notion of user reputation points from polls, or unclaimed tokens held in escrow), we’ll provide migration paths. Reputation points could simply be recalculated off-chain from all events (thanks to our robust event logging in v1). Unclaimed rewards or deposits in v1 escrows could be withdrawn by users normally. If needed, we could even offer a one-time migration service where the user signs permission and the MOA bot (via delegation) withdraws the funds from the v1 escrow and re-deposits them into the v2 system (like into the user’s Delegator). We will carefully weigh security and complexity here – in many cases, it may be easier to just let users manually claim their assets from v1.

In summary, backward compatibility will be maintained by running v1 and v2 in parallel until v1 naturally winds down, and by providing tools (and clear documentation) to bridge any important assets or data. Because we designed v1 with upgradeability in mind, the impact on existing polls is limited and manageable – no one is stuck in an obsolete contract with no way out.

Phase 3 – Future Vision: Wallet Intents & ERC-7702 Integration (MOA Bot v3)

Looking further ahead, we plan to align with Ethereum’s forthcoming ERC-7702 (wallet intents) standard as it becomes available. EIP-7702, expected in the 2025 “Pectra” network upgrade, will allow Externally Owned Accounts to temporarily behave like smart contracts without changing their address ￼ ￼. In other words, a user’s normal wallet address could execute code (or delegate execution) directly, blurring the line between EOAs and smart accounts. This has profound implications for UX and fits perfectly with the MOA bot’s Discord-based workflow:
	•	Seamless User Onboarding: With ERC-7702, users won’t even need a separate Delegator contract deployed. Their own wallet address can gain smart capabilities with a one-time opt-in. For example, a user could authorize a “delegation designator” on their EOA that points to a general Delegator implementation ￼. Once that’s set, our MOA bot can trigger on-chain actions by interacting with the user’s actual address, which internally delegates calls to the implementation contract. The user retains the same address identity across v1, v2, v3, simplifying tracking and reputation. This preserves the user’s history (no new wallet needed) and removes any migration step for assets – no tokens need to move, since the EOA itself is now empowered.
	•	“Wallet Intents” and One-Click UX: In practical terms, ERC-7702 introduces the concept of wallet intents / authorizations. Users will be able to sign a single intent that the wallet (or a trusted module) can execute as multiple actions later. For the MOA bot, this could mean a user in Discord approves a session or policy once, and thereafter our bot (or an associated agent) can execute certain actions on behalf of the user without prompting every time. For example, a user might sign an intent like “allow MOA DelegationManager to handle my poll votes for the next 1 hour”. Then, as the user interacts in Discord (e.g. votes in five different polls via slash commands), the bot can use that authorization to execute all five on-chain in a batch or as they come, without requiring five separate wallet confirmations. This dramatically reduces friction, aligning with Discord’s real-time UX. ERC-7702’s support for session keys and policy-based permissions is what makes this possible – it allows limited, scoped delegation of one’s account ￼ ￼. In essence, v3 could let the user “log in” to the MOA bot for a session, and the bot can carry out their intents within the bounds they set (e.g., only interact with the MOA’s poll contracts, only until a certain time, only using a certain token amount for stakes, etc.).
	•	Gasless and Flexible Gas Payment: By the time ERC-7702 is live, wallets like MetaMask will likely support native gas sponsorship (meta-transactions) as a core feature. This goes hand-in-hand with wallet intents – the user’s intent could specify that the MOA service or another party pays gas, or even that gas is taken in a token the user holds (via ERC-4337 paymaster logic). Our v2 already supports gasless via the Delegation Manager, but v3 might integrate it even deeper – possibly using new JSON-RPC methods (like ERC-7715’s wallet_grantPermissions) to request these capabilities from the wallet ￼. The result is an even smoother experience: no explicit signing for each transaction and no ETH required for participants, which is ideal for a Discord community setting where many users might be new to Web3.
	•	Enhanced Security & Control: Although v3 aims for fewer user prompts, security remains crucial. Wallet intents (ERC-7702) are designed to be safely handled by wallets with clear UI, because giving an EOA smart powers is akin to upgrading the car’s engine without changing the car ￼. MetaMask and others will enforce that users explicitly opt-in by signing a special transaction to add a delegation pointer to their account ￼. We anticipate that our integration will involve guiding users through this opt-in (likely a one-time setup in their wallet). Once done, users gain fine-grained control: they could revoke the MOA bot’s delegated authority easily from their wallet’s interface, or set it to expire. Our smart contracts in v3 will be adapted to respect these wallet-level rules – effectively, the Delegation Manager concept might become partially obsolete as wallets themselves take on the role of validating and executing intents. We will remain flexible: if MetaMask’s implementation still uses a form of Delegation Manager under the hood, we’ll hook into that. If instead wallets expose a direct JSON-RPC for dApps to bundle actions (as hinted by ERC-5792 for batching ￼), we will leverage it to send multi-call bundles (e.g., join poll + claim reward in one intent).

Discord-First Experience: Finally, it’s worth noting how these advancements serve our Discord community. By v3, a user should be able to participate in a poll or quiz with a single click or even a natural language command, with no MetaMask popups for each action. For instance, a Discord message “/vote 42 YES” could trigger the MOA bot to package the vote intent, and the user’s wallet (already pre-authorized via a session key) just logs it without bothering the user. This “invisible crypto” goal is exactly what standards like ERC-7702 are aiming for ￼ ￼ – users get the benefits of smart accounts (multi-step automation, sponsored gas, safety controls) while retaining their familiar wallet address and not having to understand complex crypto workflows. In the background, our contracts will take those intents and execute them trustlessly on-chain, and the Discord UI/bot will report results back to the community in real-time.

Conclusion and Proposal Fit

This three-phase roadmap outlines a clear evolution of the MOA bot’s smart contract architecture: (v1) a solid factory/escrow design with upgradeable patterns, (v2) integration of MetaMask’s Delegation Toolkit (ERC-7710) for gasless transactions via smart accounts, and (v3) harnessing upcoming wallet intent standards (ERC-7702) for an even more seamless UX. Throughout, we emphasize upgradeability, modular design, and careful event logging to ensure no user is left behind in the transition and that we can adapt to Ethereum’s rapid advances. This plan not only future-proofs the MOA bot for new Ethereum standards but also delivers immediate UX improvements (gasless polling in v2) and aligns with MetaMask’s vision for smart accounts and delegation. By implementing these phases with community feedback in mind, we aim to set a new standard for Discord-based Web3 interactions – making them as easy as Web2, without sacrificing the trustlessness and security of blockchain. The requested MetaMask grant will accelerate development of these upgrades, particularly the integration with MetaMask’s Delegation Toolkit and the R&D for ERC-7702 intents, ensuring the MOA bot can serve as a flagship use-case for these technologies in community management and engagement.

Sources: The technical approach is informed by EIP-1167 proxy patterns ￼, the ERC-7710 delegation standard ￼ ￼, MetaMask/Collab.Land’s delegation toolkit announcements ￼, and emerging research on EIP-7702 wallet intents ￼ ￼.