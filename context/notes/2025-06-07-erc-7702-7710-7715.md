# Intent-Based Multi-Agent Architecture Using ERC-7702, ERC-7710, and ERC-7715

*Date: June 7, 2025*

## Overview

This document outlines a comprehensive intent-based architecture for the Discord bot's multi-agent system, leveraging three complementary Ethereum standards:

1. **ERC-7710**: Intent Standard for creating and executing batched operations
2. **ERC-7715**: Intent for Token Transfers to simplify token operations
3. **ERC-7702**: Account Abstraction Via Alternative Mempool for EOA compatibility

By combining these standards, we create a unified system that supports all wallet types while enabling advanced features like gasless transactions, batched operations, and seamless agent interactions.

## Architecture Components

### 1. Intent Structure (ERC-7710 & ERC-7715)

```javascript
// Example intent for creating a quiz with token transfers
const intent = {
  intentId: ethers.utils.id(`create-quiz-${userId}-${Date.now()}`),
  actions: [
    // ERC-7715: Token transfer to Account Kit
    {
      type: "TOKEN_TRANSFER",
      token: tokenAddress,
      from: userAddress,
      to: accountKitAddress,
      amount: accountKitFee
    },
    // ERC-7715: Token transfer to Orchestrator
    {
      type: "TOKEN_TRANSFER",
      token: tokenAddress,
      from: userAddress,
      to: orchestratorAddress,
      amount: orchestratorFee
    },
    // ERC-7715: Token transfer to Quiz
    {
      type: "TOKEN_TRANSFER",
      token: tokenAddress,
      from: userAddress,
      to: quizAddress,
      amount: quizAmount
    },
    // ERC-7710: Initialize quiz
    {
      type: "CONTRACT_CALL",
      target: quizAddress,
      callData: quizInterface.encodeFunctionData("initialize", [quizDataHash])
    }
  ],
  validity: {
    validFrom: Math.floor(Date.now() / 1000),
    validTo: Math.floor(Date.now() / 1000) + 3600 // Valid for 1 hour
  }
};
```

### 2. Intent Handler Contract

```solidity
// Combined intent handler supporting all ERC standards
contract AgentIntentHandler is IntentHandler, ERC7702Handler {
    // Factory state variables
    address public orchestratorWallet;
    address public accountKitFeeWallet;
    uint256 public orchestratorFeePercentage;
    uint256 public accountKitFeePercentage;
    uint256 public constant FEE_DENOMINATOR = 10000;
    mapping(bytes32 => address) public quizRegistry;
    
    constructor(
        address _orchestratorWallet,
        address _accountKitFeeWallet,
        uint256 _orchestratorFeePercentage,
        uint256 _accountKitFeePercentage
    ) {
        orchestratorWallet = _orchestratorWallet;
        accountKitFeeWallet = _accountKitFeeWallet;
        orchestratorFeePercentage = _orchestratorFeePercentage;
        accountKitFeePercentage = _accountKitFeePercentage;
    }
    
    // ERC-7710 handler
    function handleIntent(Intent calldata intent) external override returns (bool) {
        require(intent.actions.length >= 3, "Invalid intent structure");
        
        // Process token transfers using ERC-7715
        for (uint i = 0; i < intent.actions.length; i++) {
            if (intent.actions[i].type == ActionType.TOKEN_TRANSFER) {
                _executeTokenTransfer(intent.actions[i]);
            } else if (intent.actions[i].type == ActionType.CONTRACT_CALL) {
                _executeContractCall(intent.actions[i]);
            }
        }
        
        // Register quiz if needed
        bytes32 quizDataHash = _extractQuizDataHash(intent);
        address quizAddress = _extractQuizAddress(intent);
        quizRegistry[quizDataHash] = quizAddress;
        
        emit IntentExecuted(intent.intentId, msg.sender);
        return true;
    }
    
    // ERC-7702 handler for EOA users
    function handleEOAUserOperation(
        UserOperation calldata userOp
    ) external override returns (bool) {
        address sender = recoverSigner(userOp);
        Intent memory intent = _convertUserOpToIntent(userOp);
        return _processIntent(intent);
    }
    
    // Helper functions
    function _executeTokenTransfer(Action calldata action) internal {
        // Validate and execute token transfer
        require(
            IERC20(action.token).transferFrom(action.from, action.to, action.amount),
            "Token transfer failed"
        );
    }
    
    function _executeContractCall(Action calldata action) internal {
        // Execute contract call
        (bool success, ) = action.target.call(action.callData);
        require(success, "Contract call failed");
    }
    
    // Other helper functions...
}
```

### 3. Quiz Escrow Contract

```solidity
contract QuizEscrow {
    address public factory;
    address public creator;
    address public tokenAddress;
    bytes32 public quizDataHash;
    uint256 public totalAmount;
    bool public initialized = false;
    
    // Track participants and their rewards
    mapping(address => uint256) public userRewards;
    mapping(address => bool) public hasClaimed;
    
    constructor(
        address _tokenAddress,
        address _creator,
        bytes32 _quizDataHash
    ) {
        factory = msg.sender;
        tokenAddress = _tokenAddress;
        creator = _creator;
        quizDataHash = _quizDataHash;
    }
    
    function initialize(uint256 _totalAmount) external {
        require(!initialized, "Already initialized");
        require(msg.sender == factory, "Only factory can initialize");
        
        totalAmount = _totalAmount;
        initialized = true;
    }
    
    // Intent-compatible reward distribution
    function assignReward(address user, uint256 amount) external {
        require(msg.sender == factory || msg.sender == creator, "Unauthorized");
        require(!hasClaimed[user], "Already claimed");
        
        userRewards[user] = amount;
    }
    
    function claimReward(address user) external {
        require(userRewards[user] > 0, "No reward available");
        require(!hasClaimed[user], "Already claimed");
        
        uint256 amount = userRewards[user];
        hasClaimed[user] = true;
        
        require(
            IERC20(tokenAddress).transfer(user, amount),
            "Reward transfer failed"
        );
    }
}
```

## Integration with Account Kit SDK

### 1. Intent Creation and Execution

```javascript
class IntentManager {
  constructor(accountKit, provider) {
    this.accountKit = accountKit;
    this.provider = provider;
    this.intentHandlerAddress = INTENT_HANDLER_ADDRESS;
  }
  
  async createQuizIntent(params) {
    const {
      userAddress,
      tokenAddress,
      totalAmount,
      quizDataHash,
      quizAddress
    } = params;
    
    // Get fee configuration from contract
    const intentHandler = new ethers.Contract(
      this.intentHandlerAddress,
      INTENT_HANDLER_ABI,
      this.provider
    );
    
    const accountKitFeePercentage = await intentHandler.accountKitFeePercentage();
    const orchestratorFeePercentage = await intentHandler.orchestratorFeePercentage();
    
    // Calculate fee amounts
    const accountKitFee = totalAmount.mul(accountKitFeePercentage).div(10000);
    const orchestratorFee = totalAmount.mul(orchestratorFeePercentage).div(10000);
    const quizAmount = totalAmount.sub(accountKitFee).sub(orchestratorFee);
    
    // Create intent
    const intent = {
      intentId: ethers.utils.id(`create-quiz-${userAddress}-${Date.now()}`),
      actions: [
        // Token transfers
        {
          type: "TOKEN_TRANSFER",
          token: tokenAddress,
          from: userAddress,
          to: await intentHandler.accountKitFeeWallet(),
          amount: accountKitFee
        },
        {
          type: "TOKEN_TRANSFER",
          token: tokenAddress,
          from: userAddress,
          to: await intentHandler.orchestratorWallet(),
          amount: orchestratorFee
        },
        {
          type: "TOKEN_TRANSFER",
          token: tokenAddress,
          from: userAddress,
          to: quizAddress,
          amount: quizAmount
        },
        // Initialize quiz
        {
          type: "CONTRACT_CALL",
          target: quizAddress,
          callData: QUIZ_INTERFACE.encodeFunctionData("initialize", [quizAmount])
        }
      ],
      validity: {
        validFrom: Math.floor(Date.now() / 1000),
        validTo: Math.floor(Date.now() / 1000) + 3600 // Valid for 1 hour
      }
    };
    
    return intent;
  }
  
  async executeIntent(intent, wallet) {
    // Check if smart account or EOA
    const isSmartAccount = await this.accountKit.isSmartAccount(wallet.address);
    
    if (isSmartAccount) {
      // Handle as ERC-7710/7715 intent
      const signedIntent = await this.accountKit.signIntent(intent, wallet);
      return this.accountKit.executeIntent(signedIntent);
    } else {
      // Handle as ERC-7702 UserOperation
      const userOp = await this.accountKit.createUserOperation({
        sender: wallet.address,
        intent: intent,
        callData: INTENT_HANDLER_INTERFACE.encodeFunctionData(
          "handleEOAUserOperation",
          [/* userOp structure */]
        )
      });
      
      // Sign user operation
      const signature = await wallet.signMessage(
        ethers.utils.arrayify(ethers.utils.keccak256(userOp))
      );
      userOp.signature = signature;
      
      // Submit to bundler
      return this.accountKit.submitUserOperation(userOp);
    }
  }
}
```

### 2. Discord Bot Implementation

```javascript
// In Discord command handler
async function handleQuizCreation(interaction, url, tokenAddress, amount) {
  try {
    // 1. Generate quiz content
    const quizData = await generateQuizFromUrl(url);
    const quizDataHash = ethers.utils.id(JSON.stringify(quizData));
    
    // 2. Calculate deterministic quiz address
    const quizAddress = await calculateQuizAddress(
      quizDataHash,
      interaction.user.id,
      tokenAddress
    );
    
    // 3. Create intent
    const intentManager = new IntentManager(accountKit, provider);
    const intent = await intentManager.createQuizIntent({
      userAddress: getUserWalletAddress(interaction.user.id),
      tokenAddress,
      totalAmount: ethers.utils.parseUnits(amount.toString(), 18),
      quizDataHash,
      quizAddress
    });
    
    // 4. Display fee breakdown to user
    await displayFeeBreakdown(interaction, intent);
    
    // 5. Execute intent after user confirmation
    const confirmationCollector = interaction.channel.createMessageComponentCollector({
      filter: i => i.user.id === interaction.user.id,
      time: 60000
    });
    
    confirmationCollector.on('collect', async i => {
      if (i.customId === 'confirm_quiz') {
        // Get user wallet
        const wallet = await accountKit.getWallet(interaction.user.id);
        
        // Execute intent
        await intentManager.executeIntent(intent, wallet);
        
        await i.update({ content: 'Quiz created successfully!', components: [] });
      }
    });
  } catch (error) {
    console.error(error);
    await interaction.reply({ content: 'Error creating quiz', ephemeral: true });
  }
}
```

## User Experience

### 1. Quiz Creation Flow

1. User types `/mother learn create-quiz [url] [token] [amount]` in Discord
2. Bot generates quiz content and prepares intent
3. Bot shows fee breakdown:
   ```
   üèÜ New Quiz: "Ethereum Basics"
   
   üí∞ Token: USDC
   üí∏ Total Amount: 100 USDC
   
   Fee Breakdown:
   - Account Kit Fee: 2 USDC (2%)
   - Mother Agent Fee: 5 USDC (5%)
   - Quiz Rewards Pool: 93 USDC (93%)
   
   Press ‚úÖ to approve this transaction
   ```
4. User confirms transaction
5. AccountKit handles wallet type detection and transaction execution
6. User receives confirmation when quiz is deployed

### 2. Quiz Participation Flow

1. User takes quiz in Discord
2. Bot tracks quiz progress and correct answers
3. After completion, bot creates reward intent
4. Intent transfers tokens from escrow to user
5. User receives tokens with no transaction required

## Multi-Agent Architecture Implications

With this intent-based system:

1. **Each agent domain (learn, defi, dao, etc.) can:**
   - Define its own specialized intents
   - Handle specific parts of intent execution
   - Add specialized validation logic

2. **Orchestrator agent responsibilities:**
   - Intent verification and validation
   - Fee distribution management
   - Cross-agent intent coordination

3. **Fee structure becomes modular:**
   - Base fee for orchestrator
   - Domain-specific fees for specialized agents
   - Account Kit fee for wallet operations

4. **Permission system integration:**
   - Intent validation can include role-based checks
   - Certain intent types restricted to specific roles
   - Permission verification at intent creation time

## Technical Benefits

1. **Gas Efficiency**
   - Batched operations reduce gas costs
   - Gasless transactions for users
   - Shared execution costs across multi-step processes

2. **Security Improvements**
   - Atomic execution of multi-step operations
   - Standardized validation protocols
   - Transaction simulation before execution

3. **Flexibility**
   - Support for all wallet types (Smart Accounts + EOAs)
   - Progressive upgrade path for users
   - Extensible to new agent types and capabilities

4. **User Experience**
   - One-click approval for complex operations
   - No wallet-switching requirements
   - Transparent fee structure

## Implementation Roadmap

### Phase 1: Intent Preparation
- Implement intent creation infrastructure
- Design intent structures for existing features
- Update UI to display intent information

### Phase 2: Smart Account Integration
- Integrate ERC-7710/7715 for smart account users
- Deploy intent handler contracts
- Implement intent execution via Account Kit

### Phase 3: EOA Compatibility
- Add ERC-7702 support for EOA users
- Integrate with bundler network
- Implement user operation creation and signing

### Phase 4: Multi-Agent Decomposition
- Refactor each domain as specialized intent handler
- Implement cross-agent intent coordination
- Deploy agent-specific validation logic

## Conclusion

By combining ERC-7702, ERC-7710, and ERC-7715, our Discord bot's multi-agent architecture becomes truly composable, extensible, and user-friendly. This intent-based design supports all wallet types while enabling advanced features like gasless transactions, fee splitting, and atomic multi-step operations. The architecture seamlessly scales from a monolithic implementation to a fully distributed multi-agent system while maintaining a consistent user experience.
