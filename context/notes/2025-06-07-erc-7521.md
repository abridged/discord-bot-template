# ERC-7521: Generalized Intents for Smart Contract Wallets

*Date: June 7, 2025*

## Standard Overview

ERC-7521 defines a generalized intent specification for smart contract wallets, allowing authorization of current and future intent structures at sign time. This standard provides a common framework for intent-based transactions, enabling a more flexible and user-friendly experience when interacting with blockchain applications.

## Key Components

### 1. Intent Structure

```javascript
// Basic structure of an intent according to ERC-7521
struct Intent {
    bytes32 intentId;       // Unique identifier for the intent
    uint256 validUntil;     // Timestamp for intent expiration
    address intentAccount;  // Account issuing the intent
    bytes intentData;       // Custom data for the specific intent type
    bytes32 salt;           // Random value to ensure uniqueness
    string intentType;      // The type identifier for this intent
}
```

### 2. Intent Handler Interface

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IIntentHandler {
    // Handle an intent
    function handleIntent(bytes calldata intentData) external returns (bool);
    
    // Check if an intent can be executed
    function canHandleIntent(bytes calldata intentData) external view returns (bool);
    
    // Get the intent type this handler supports
    function intentType() external view returns (string memory);
}
```

## Implementation Guide for Discord Bot Integration

### 1. Intent Creation

```javascript
class IntentBuilder {
    // Create a generic intent structure
    static createIntent(intentType, data, account) {
        const now = Math.floor(Date.now() / 1000);
        
        return {
            intentId: ethers.utils.id(`${intentType}-${account}-${now}`),
            validUntil: now + 3600, // Valid for 1 hour
            intentAccount: account,
            intentData: ethers.utils.defaultAbiCoder.encode(
                data.types,
                data.values
            ),
            salt: ethers.utils.randomBytes(32),
            intentType: intentType
        };
    }
    
    // Create a quiz creation intent
    static createQuizIntent(creator, quizUrl, tokenAddress, amount) {
        return this.createIntent(
            'QUIZ_CREATION',
            {
                types: ['address', 'string', 'address', 'uint256'],
                values: [creator, quizUrl, tokenAddress, amount]
            },
            creator
        );
    }
    
    // Create a token distribution intent
    static createTokenDistributionIntent(sender, recipients, amounts, tokenAddress) {
        return this.createIntent(
            'TOKEN_DISTRIBUTION',
            {
                types: ['address', 'address[]', 'uint256[]', 'address'],
                values: [sender, recipients, amounts, tokenAddress]
            },
            sender
        );
    }
}
```

### 2. Intent Handler Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IIntentHandler.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract QuizIntentHandler is IIntentHandler {
    function handleIntent(bytes calldata intentData) external override returns (bool) {
        // Decode intent data
        (address creator, string memory quizUrl, address token, uint256 amount) = 
            abi.decode(intentData, (address, string, address, uint256));
        
        // Validate intent
        require(creator != address(0), "Invalid creator");
        require(token != address(0), "Invalid token");
        require(amount > 0, "Invalid amount");
        
        // Execute token transfer
        bool success = IERC20(token).transferFrom(creator, address(this), amount);
        require(success, "Token transfer failed");
        
        // Create quiz contract and initialize it
        address quizContract = deployQuizContract(quizUrl, creator, token, amount);
        
        emit QuizCreated(quizContract, creator, token, amount);
        
        return true;
    }
    
    function canHandleIntent(bytes calldata intentData) external view override returns (bool) {
        try {
            // Try to decode the intent data
            (address creator, , address token, uint256 amount) = 
                abi.decode(intentData, (address, string, address, uint256));
                
            // Check if values are valid
            if (creator == address(0) || token == address(0) || amount == 0) {
                return false;
            }
            
            // Check if creator has enough allowance and balance
            if (IERC20(token).allowance(creator, address(this)) < amount) {
                return false;
            }
            if (IERC20(token).balanceOf(creator) < amount) {
                return false;
            }
            
            return true;
        } catch {
            return false;
        }
    }
    
    function intentType() external pure override returns (string memory) {
        return "QUIZ_CREATION";
    }
    
    // Deploy a quiz contract
    function deployQuizContract(
        string memory quizUrl,
        address creator,
        address token,
        uint256 amount
    ) internal returns (address) {
        // CREATE2 deployment logic
        // ...
        
        return address(0); // Replace with actual deployment
    }
    
    event QuizCreated(
        address indexed quizContract,
        address indexed creator,
        address indexed token,
        uint256 amount
    );
}
```

### 3. Discord Bot Integration

```javascript
// Function to create and sign an intent
async function handleQuizCreation(interaction) {
    // Extract parameters from the Discord interaction
    const quizUrl = interaction.options.getString('url');
    const tokenAddress = interaction.options.getString('token');
    const amount = interaction.options.getString('amount');
    
    // Get user wallet address
    const userAddress = await getUserWalletAddress(interaction.user.id);
    
    // Create the intent
    const intent = IntentBuilder.createQuizIntent(
        userAddress,
        quizUrl,
        tokenAddress,
        ethers.utils.parseUnits(amount, 18) // Assuming 18 decimals
    );
    
    // Display intent to user
    await interaction.reply({
        content: `
        ðŸ† New Quiz Intent
        
        URL: ${quizUrl}
        Token: ${tokenAddress}
        Amount: ${amount} tokens
        
        Please confirm this intent by clicking the button below.
        `,
        components: [/* UI components for signing */],
        ephemeral: true
    });
    
    // Handle signature and submission
    // ...
}
```

## Benefits for Discord Bot Users

1. **Simplified User Experience**
   - Sign once for complex transactions
   - No need to approve individual steps
   - Gasless transactions possible

2. **Enhanced Security**
   - Clear visibility of intended operations
   - Validate full operation before signing
   - Revoke unexecuted intents

3. **Flexibility and Cost Efficiency**
   - Batched operations for gas savings
   - Optimized execution paths
   - Retry flexibility without new signatures

## Example Use Cases in Discord Bots

1. **Quiz Management**
   - Create quizzes with token rewards
   - Distribute rewards to multiple winners in one transaction
   - Calculate and distribute fees to stakeholders

2. **Token Distribution**
   - Airdrops to multiple community members
   - Reward distribution for various activities
   - Batch token transfers for gas efficiency

3. **Governance Actions**
   - Create proposals for DAO voting
   - Execute batch voting actions
   - Implement governance decisions

## Integration with Other Standards

ERC-7521 works well with:

1. **ERC-7702 (Account Abstraction via Alternative Mempool)**
   - Users with EOA wallets can create intents
   - Bundlers can execute intents as UserOperations
   - Seamless experience for all wallet types

2. **ERC-7715 (Intent for Token Transfers)**
   - Specialized token actions within intents
   - Standardized token transfer patterns
   - Fee distribution for token operations

By implementing ERC-7521, Discord bots can provide a more intuitive and efficient blockchain experience, reducing the complexity of multi-step processes and enhancing the overall user experience.
