# ERC-7710: Smart Contract Delegation

*Date: June 7, 2025*

## Standard Overview

ERC-7710 defines a standard way for smart contracts to delegate capabilities to other smart contracts or Externally Owned Accounts (EOAs). This enables more flexible contract interactions through a standardized delegation framework, allowing contracts to authorize specific actions to be performed on their behalf.

## Key Components

### 1. Delegation Interface

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title ERC7710Manager
 * @notice Interface for Delegation Manager that exposes the redeemDelegations function.
 */
interface ERC7710Manager {
    /**
     * @notice This method validates the provided permission contexts and executes the execution if the caller has authority to do so
     * @param proofs The proofs that prove the caller has the authority to execute on behalf of the account.
     * @param account The account to execute on behalf of.
     * @param execution The execution to perform.
     * @return success Whether the execution was successful.
     * @return result The result of the execution.
     */
    function redeemDelegations(
        bytes[] calldata proofs,
        address account,
        Execution calldata execution
    ) external returns (bool success, bytes memory result);
}

/**
 * @title Execution
 * @notice A struct representing an execution.
 */
struct Execution {
    address target;    // The contract to call
    bytes data;        // The calldata to send
    uint256 value;     // The amount of ETH to send
}
```

### 2. Permission Proof Structure

```javascript
// Structure for delegation proof
const delegationProof = {
  delegator: '0xDelegatorAddress',  // The address granting permission
  delegatee: '0xDelegateeAddress',  // The address receiving permission
  permissions: [                    // Array of specific permissions
    {
      target: '0xTargetContractAddress',
      functionSelector: '0xSelector', // 4-byte function selector
      validUntil: 1717503600          // Unix timestamp expiration
    }
  ],
  nonce: 123,                       // To prevent replay attacks
  signature: '0x...'                // Signed by the delegator
};
```

### 3. Delegation Manager Implementation

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./ERC7710Manager.sol";

contract DelegationManager is ERC7710Manager {
    // Mapping to track used nonces per delegator
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    
    // Events
    event DelegationExecuted(
        address indexed delegator,
        address indexed delegatee,
        address indexed target,
        bytes4 selector
    );
    
    /**
     * @notice Execute a function on behalf of another account using delegation proofs
     * @param proofs Array of signed delegation proofs
     * @param account The account to execute on behalf of
     * @param execution The execution details
     */
    function redeemDelegations(
        bytes[] calldata proofs,
        address account,
        Execution calldata execution
    ) external override returns (bool success, bytes memory result) {
        // Verify at least one proof is provided
        require(proofs.length > 0, "No delegation proofs provided");
        
        // Extract function selector from execution data
        bytes4 selector = bytes4(execution.data);
        
        // Validate at least one proof authorizes this execution
        bool authorized = false;
        for (uint i = 0; i < proofs.length; i++) {
            if (_validateProof(proofs[i], account, execution.target, selector)) {
                authorized = true;
                break;
            }
        }
        
        require(authorized, "No valid delegation proof found");
        
        // Execute the delegated call
        (success, result) = execution.target.call{value: execution.value}(execution.data);
        
        // Emit event on successful execution
        if (success) {
            emit DelegationExecuted(account, msg.sender, execution.target, selector);
        }
        
        return (success, result);
    }
    
    /**
     * @notice Validate a delegation proof
     * @param proof The signed delegation proof
     * @param delegator The account delegating permission
     * @param target The target contract
     * @param selector The function selector
     * @return valid Whether the proof is valid
     */
    function _validateProof(
        bytes calldata proof,
        address delegator,
        address target,
        bytes4 selector
    ) internal returns (bool valid) {
        // Decode the proof
        (address recoveredDelegator, address delegatee, Permission[] memory permissions, uint256 nonce, bytes memory signature) = 
            abi.decode(proof, (address, address, Permission[], uint256, bytes));
        
        // Verify delegator matches
        require(recoveredDelegator == delegator, "Delegator mismatch");
        
        // Verify delegatee matches caller
        require(delegatee == msg.sender, "Delegatee mismatch");
        
        // Verify nonce hasn't been used
        require(!usedNonces[delegator][nonce], "Nonce already used");
        
        // Mark nonce as used
        usedNonces[delegator][nonce] = true;
        
        // Verify permission exists for this target and selector
        for (uint i = 0; i < permissions.length; i++) {
            Permission memory permission = permissions[i];
            
            if (permission.target == target && 
                permission.functionSelector == selector &&
                block.timestamp <= permission.validUntil) {
                
                // Verify signature
                bytes32 messageHash = keccak256(abi.encode(
                    delegator,
                    delegatee,
                    permissions,
                    nonce
                ));
                
                bytes32 signedHash = keccak256(abi.encodePacked(
                    "\x19Ethereum Signed Message:\n32",
                    messageHash
                ));
                
                address recovered = _recoverSigner(signedHash, signature);
                if (recovered == delegator) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * @notice Recover the signer of a signature
     */
    function _recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        // Signature recovery logic
        // ...
        
        // Placeholder for actual implementation
        return address(0);
    }
}

/**
 * @notice Structure representing a permission
 */
struct Permission {
    address target;           // Contract that can be called
    bytes4 functionSelector;  // Function that can be called
    uint256 validUntil;       // Expiration timestamp
}
```

## Implementation Guide for Discord Bot Integration

### 1. Client-Side Integration

```javascript
class DelegationClient {
    constructor(provider, delegationManagerAddress) {
        this.provider = provider;
        this.delegationManager = new ethers.Contract(
            delegationManagerAddress,
            DELEGATION_MANAGER_ABI,
            provider
        );
    }
    
    // Create a delegation permission
    async createDelegation(signer, delegatee, targetContract, functionName, validityDuration = 3600) {
        const contract = new ethers.Contract(targetContract, TARGET_ABI, this.provider);
        const functionSelector = contract.interface.getSighash(functionName);
        
        const nonce = await this._getNextNonce(signer.address);
        const validUntil = Math.floor(Date.now() / 1000) + validityDuration;
        
        const permissions = [{
            target: targetContract,
            functionSelector: functionSelector,
            validUntil: validUntil
        }];
        
        // Create signature
        const messageHash = ethers.utils.keccak256(
            ethers.utils.defaultAbiCoder.encode(
                ['address', 'address', 'tuple(address,bytes4,uint256)[]', 'uint256'],
                [signer.address, delegatee, permissions, nonce]
            )
        );
        
        const signature = await signer.signMessage(ethers.utils.arrayify(messageHash));
        
        // Return the delegation proof
        return ethers.utils.defaultAbiCoder.encode(
            ['address', 'address', 'tuple(address,bytes4,uint256)[]', 'uint256', 'bytes'],
            [signer.address, delegatee, permissions, nonce, signature]
        );
    }
    
    // Execute a function using delegation
    async executeWithDelegation(delegationProof, account, targetContract, functionName, args = [], value = 0) {
        const contract = new ethers.Contract(targetContract, TARGET_ABI, this.provider);
        const calldata = contract.interface.encodeFunctionData(functionName, args);
        
        const execution = {
            target: targetContract,
            data: calldata,
            value: value
        };
        
        return this.delegationManager.redeemDelegations(
            [delegationProof],
            account,
            execution
        );
    }
    
    // Helper method to get the next available nonce
    async _getNextNonce(address) {
        // Implementation would depend on how nonces are tracked
        return Math.floor(Math.random() * 1000000);
    }
}
```

### 2. Discord Bot Command Handler

```javascript
async function handleDelegatedQuizCreation(interaction) {
    try {
        // Get user's account
        const userAccount = await getUserAccount(interaction.user.id);
        
        // Create delegation client
        const delegationClient = new DelegationClient(provider, DELEGATION_MANAGER_ADDRESS);
        
        // Bot's address that will execute on behalf of the user
        const botExecutor = BOT_EXECUTOR_ADDRESS;
        
        // Target quiz factory contract
        const quizFactory = QUIZ_FACTORY_ADDRESS;
        
        // Create a delegation permission for the quiz creation function
        const delegationProof = await delegationClient.createDelegation(
            userAccount,
            botExecutor,
            quizFactory,
            'createQuiz',
            3600 // Valid for 1 hour
        );
        
        await interaction.reply({
            content: 'Delegation created! The bot can now create a quiz on your behalf for the next hour.',
            ephemeral: true
        });
        
        // Store delegation proof for later use
        await storeDelegationProof(interaction.user.id, delegationProof);
        
    } catch (error) {
        console.error(error);
        await interaction.reply({
            content: 'Failed to create delegation: ' + error.message,
            ephemeral: true
        });
    }
}

async function executeQuizCreation(userId, quizParams) {
    try {
        // Get the stored delegation proof
        const delegationProof = await getDelegationProof(userId);
        if (!delegationProof) {
            throw new Error('No valid delegation found');
        }
        
        // Get user's account
        const userAccount = await getUserAccount(userId);
        
        // Create delegation client
        const delegationClient = new DelegationClient(provider, DELEGATION_MANAGER_ADDRESS);
        
        // Execute quiz creation on behalf of the user
        const result = await delegationClient.executeWithDelegation(
            delegationProof,
            userAccount.address,
            QUIZ_FACTORY_ADDRESS,
            'createQuiz',
            [
                quizParams.title,
                quizParams.questions,
                quizParams.tokenAddress,
                quizParams.rewardAmount
            ]
        );
        
        return result;
    } catch (error) {
        console.error(error);
        throw error;
    }
}
```

## Benefits for Discord Bot Users

1. **Gasless Transactions**
   - Users can delegate quiz creation to the bot
   - Bot pays for gas on their behalf
   - Improved onboarding for new users without ETH

2. **Enhanced Security**
   - Granular delegation of specific function permissions
   - Time-limited authorizations
   - No need to share private keys

3. **Better User Experience**
   - Sign once, execute multiple times
   - Fewer transaction prompts
   - Batched operations possible

## Example Use Cases in Discord Bots

1. **Quiz Creation and Management**
   - Users delegate quiz creation permission
   - Bot creates and manages quizzes on user's behalf
   - Quiz rewards come from user's tokens

2. **Token Operations**
   - Delegated token transfers to winners
   - Automated reward distribution
   - Fee payments

3. **Governance Actions**
   - Delegate voting rights
   - Automated proposal creation
   - Vote execution by proxy

## Integration with Other Standards

ERC-7710 can work well with:

1. **ERC-7702 (Account Abstraction via Alternative Mempool)**
   - Enable gasless execution through delegated operations
   - Bundlers can use delegation proofs to execute

2. **ERC-7521 (Generalized Intents for Smart Contract Wallets)**
   - Delegation can be combined with intent-based systems
   - Delegated intent execution

By implementing ERC-7710, Discord bots can provide a seamless user experience while maintaining security and flexibility in smart contract interactions.
