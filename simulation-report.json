{
  "duration": 1978,
  "scenarios": [
    {
      "scenario": "Happy Path - 5 Users",
      "success": true,
      "result": {
        "success": true,
        "duration": 565,
        "phases": {
          "deployment": {
            "quiz": {
              "id": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "creatorDiscordId": "123456789012345678",
              "creatorWalletAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
              "sourceUrl": "https://simulation.example.com/quiz",
              "difficulty": "medium",
              "questionCount": 1,
              "tokenAddress": "0x0000000000000000000000000000000000000000",
              "chainId": 31337,
              "rewardAmount": "100000000000000000",
              "contractAddress": null,
              "status": "active",
              "createdAt": "2025-06-20T21:45:24.130Z",
              "participants": [],
              "escrowAddress": "0x6D544390Eb535d61e196c87d6B9c80dCD8628Acd",
              "transactionHash": "0xd0d59a4b5ed1a3e02b47065654bd5eddc8139e81396645693f5cfe8e13c05cfb",
              "onChain": true,
              "expiryTime": 1750542324,
              "fundingStatus": "funded"
            },
            "question": {
              "id": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionText": "What is the capital of France?",
              "options": [
                "London",
                "Paris",
                "Berlin",
                "Madrid"
              ],
              "correctAnswer": 1,
              "explanation": "Paris is the capital and largest city of France.",
              "createdAt": "2025-06-20T21:45:24.130Z"
            },
            "escrowAddress": "0x6D544390Eb535d61e196c87d6B9c80dCD8628Acd",
            "transactionHash": "0xd0d59a4b5ed1a3e02b47065654bd5eddc8139e81396645693f5cfe8e13c05cfb"
          },
          "participation": [
            {
              "id": "answer_1750455924136_8yu9lt3sd",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionId": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "userDiscordId": "10113944049335409",
              "userWalletAddress": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
              "selectedOptionIndex": 2,
              "isCorrect": false,
              "answeredAt": "2025-06-20T21:45:24.136Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924237_d9bqb04cf",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionId": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "userDiscordId": "10034406514491978",
              "userWalletAddress": "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.237Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924338_x2r2c3n9z",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionId": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "userDiscordId": "10273292936419680",
              "userWalletAddress": "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.338Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924439_7l2if956a",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionId": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "userDiscordId": "10720293993765738",
              "userWalletAddress": "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.439Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924539_vlhrt1rki",
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "questionId": "54b5973e-b9b3-4ee1-9113-9c94f66ec2cc",
              "userDiscordId": "10271254864003160",
              "userWalletAddress": "0x976EA74026E726554dB657fA54763abd0C3a0aa9",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.539Z",
              "onChain": false
            }
          ],
          "recording": [
            {
              "answerId": "answer_1750455924136_8yu9lt3sd",
              "userAddress": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
              "transactionHash": "0xb63be9a6970c757d09bf88780daee4aae088b2f0617b9464691e86fe1cf04d61",
              "gasUsed": {
                "type": "BigNumber",
                "hex": "0x03553a"
              }
            },
            {
              "answerId": "answer_1750455924237_d9bqb04cf",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x4f3347cf6ebfae32380c7c93b740a313e954327428b25631a1b3a8c57bc71663\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455924338_x2r2c3n9z",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0xb7e500b8197bdc2f9d371b496041be79edf54f2f264ba7ddedd0178602774af1\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455924439_7l2if956a",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0xe98990c5c522c30aa2622782bb0920b5069f148f10e0f98474920179ceec8aff\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455924539_vlhrt1rki",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x59c94b4961b904e52b66ccc8fbbf2107262ac1640a76003d6bee4d684055ab07\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            }
          ],
          "verification": {
            "simulation": {
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "escrowAddress": "0x6D544390Eb535d61e196c87d6B9c80dCD8628Acd",
              "participants": 5,
              "answers": 5
            },
            "database": {
              "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
              "totalParticipants": 0,
              "correctAnswers": 0,
              "incorrectAnswers": 0,
              "onChainAnswers": 0,
              "quiz": {
                "id": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
                "quizId": "415b1288-99dd-46e6-8926-c5d7cc0323fd",
                "creatorDiscordId": "123456789012345678",
                "creatorWalletAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
                "sourceUrl": "https://simulation.example.com/quiz",
                "difficulty": "medium",
                "questionCount": 1,
                "tokenAddress": "0x0000000000000000000000000000000000000000",
                "chainId": 31337,
                "rewardAmount": "100000000000000000",
                "contractAddress": null,
                "status": "active",
                "createdAt": "2025-06-20T21:45:24.130Z",
                "participants": [],
                "escrowAddress": "0x6D544390Eb535d61e196c87d6B9c80dCD8628Acd",
                "transactionHash": "0xd0d59a4b5ed1a3e02b47065654bd5eddc8139e81396645693f5cfe8e13c05cfb",
                "onChain": true,
                "expiryTime": 1750542324,
                "fundingStatus": "funded"
              },
              "answers": []
            },
            "contract": {
              "creator": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
              "correctReward": "0.06",
              "incorrectReward": "0.04",
              "fundingAmount": "0.099",
              "remainingBalance": "0.059",
              "totalCorrectAnswers": "0",
              "totalIncorrectAnswers": "1",
              "totalParticipants": "1",
              "totalPaidOut": "0.04",
              "creationTime": "2025-06-20T21:45:29.000Z",
              "isEnded": false
            },
            "verification": {
              "databaseContractSync": false,
              "allAnswersOnChain": true,
              "balanceCalculation": "verified"
            }
          }
        }
      },
      "duration": 565
    },
    {
      "scenario": "Scale Test - 10 Users",
      "success": true,
      "result": {
        "success": true,
        "duration": 1069,
        "phases": {
          "deployment": {
            "quiz": {
              "id": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "creatorDiscordId": "123456789012345678",
              "creatorWalletAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
              "sourceUrl": "https://simulation.example.com/quiz",
              "difficulty": "medium",
              "questionCount": 1,
              "tokenAddress": "0x0000000000000000000000000000000000000000",
              "chainId": 31337,
              "rewardAmount": "200000000000000000",
              "contractAddress": null,
              "status": "active",
              "createdAt": "2025-06-20T21:45:24.695Z",
              "participants": [],
              "escrowAddress": "0xB1eDe3F5AC8654124Cb5124aDf0Fd3885CbDD1F7",
              "transactionHash": "0x4d42b47b3bfc447a471ba773b8e15dde2d679087158c40d6f64fffc96f192946",
              "onChain": true,
              "expiryTime": 1750542324,
              "fundingStatus": "funded"
            },
            "question": {
              "id": "716c2471-13be-4787-b3b8-7830218d32e2",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionText": "What is the capital of France?",
              "options": [
                "London",
                "Paris",
                "Berlin",
                "Madrid"
              ],
              "correctAnswer": 1,
              "explanation": "Paris is the capital and largest city of France.",
              "createdAt": "2025-06-20T21:45:24.695Z"
            },
            "escrowAddress": "0xB1eDe3F5AC8654124Cb5124aDf0Fd3885CbDD1F7",
            "transactionHash": "0x4d42b47b3bfc447a471ba773b8e15dde2d679087158c40d6f64fffc96f192946"
          },
          "participation": [
            {
              "id": "answer_1750455924699_1fyicye88",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10447897526532596",
              "userWalletAddress": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
              "selectedOptionIndex": 2,
              "isCorrect": false,
              "answeredAt": "2025-06-20T21:45:24.699Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924801_dmkqj90r2",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10930923699301756",
              "userWalletAddress": "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.801Z",
              "onChain": false
            },
            {
              "id": "answer_1750455924902_t4x19ikjs",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10613419652889591",
              "userWalletAddress": "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:24.902Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925003_gwo0butoe",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10982980911148014",
              "userWalletAddress": "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:25.003Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925104_pm7ttzcmr",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10517207489716779",
              "userWalletAddress": "0x976EA74026E726554dB657fA54763abd0C3a0aa9",
              "selectedOptionIndex": 2,
              "isCorrect": false,
              "answeredAt": "2025-06-20T21:45:25.104Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925205_ezg9oht9u",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10356779473176738",
              "userWalletAddress": "0x14dC79964da2C08b23698B3D3cc7Ca32193d9955",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:25.205Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925307_62w40wjg8",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10646453437540493",
              "userWalletAddress": "0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:25.307Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925408_8z7poe7i7",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10498690903889528",
              "userWalletAddress": "0xa0Ee7A142d267C1f36714E4a8F75612F20a79720",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:25.408Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925509_f6njaz8t1",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10519784375921902",
              "userWalletAddress": "0xBcd4042DE499D14e55001CcbB24a551F3b954096",
              "selectedOptionIndex": 1,
              "isCorrect": true,
              "answeredAt": "2025-06-20T21:45:25.509Z",
              "onChain": false
            },
            {
              "id": "answer_1750455925610_lkepyl096",
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "questionId": "716c2471-13be-4787-b3b8-7830218d32e2",
              "userDiscordId": "10729883104743295",
              "userWalletAddress": "0x71bE63f3384f5fb98995898A86B02Fb2426c5788",
              "selectedOptionIndex": 2,
              "isCorrect": false,
              "answeredAt": "2025-06-20T21:45:25.610Z",
              "onChain": false
            }
          ],
          "recording": [
            {
              "answerId": "answer_1750455924699_1fyicye88",
              "userAddress": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
              "transactionHash": "0x25ba324e2b092ed679944bb32680b5e19c0e858b8f33b08597d6699b10319766",
              "gasUsed": {
                "type": "BigNumber",
                "hex": "0x03553a"
              }
            },
            {
              "answerId": "answer_1750455924801_dmkqj90r2",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0xd803e7d7eba292e0481adb74a01e6465bd49959baff09ecf9a769f27cdcf02d0\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455924902_t4x19ikjs",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x1def7e36f5be671c9e27c26b729b9a641e8da0b76fc5eabdcfd3e64e217f0fe7\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925003_gwo0butoe",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x1df15e3fd690f798b8fd52daa921431ad7064d51ca9b310855b5b4ff065ca177\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925104_pm7ttzcmr",
              "userAddress": "0x976EA74026E726554dB657fA54763abd0C3a0aa9",
              "transactionHash": "0x2bdd551132296939e1d39a2d8ce7efec682f1ee927d62feb8c1b90bed3d05048",
              "gasUsed": {
                "type": "BigNumber",
                "hex": "0x024a16"
              }
            },
            {
              "answerId": "answer_1750455925205_ezg9oht9u",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0xa4c3e874b72d355be2e2c9dd98afb9d65f331706218b17a96f5332a83085313d\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925307_62w40wjg8",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0xb5e9a6845618be2caf6286c0c0e7c9bc8047afd45abad17af822e269ec6f7d81\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925408_8z7poe7i7",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x01b75be250d6939502e494354a76b9bb85f7c70eddb76cec52ddf5f291ee78df\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925509_f6njaz8t1",
              "error": "insufficient funds for intrinsic transaction cost [ See: https://links.ethers.org/v5-errors-INSUFFICIENT_FUNDS ] (error={\"stackTrace\":[{\"type\":0,\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"recordQuizResult\",\"line\":136,\"range\":[4925,6482]},\"functionType\":1},{\"type\":4,\"returnData\":{\"0\":8,\"1\":195,\"2\":121,\"3\":160,\"4\":0,\"5\":0,\"6\":0,\"7\":0,\"8\":0,\"9\":0,\"10\":0,\"11\":0,\"12\":0,\"13\":0,\"14\":0,\"15\":0,\"16\":0,\"17\":0,\"18\":0,\"19\":0,\"20\":0,\"21\":0,\"22\":0,\"23\":0,\"24\":0,\"25\":0,\"26\":0,\"27\":0,\"28\":0,\"29\":0,\"30\":0,\"31\":0,\"32\":0,\"33\":0,\"34\":0,\"35\":32,\"36\":0,\"37\":0,\"38\":0,\"39\":0,\"40\":0,\"41\":0,\"42\":0,\"43\":0,\"44\":0,\"45\":0,\"46\":0,\"47\":0,\"48\":0,\"49\":0,\"50\":0,\"51\":0,\"52\":0,\"53\":0,\"54\":0,\"55\":0,\"56\":0,\"57\":0,\"58\":0,\"59\":0,\"60\":0,\"61\":0,\"62\":0,\"63\":0,\"64\":0,\"65\":0,\"66\":0,\"67\":41,\"68\":81,\"69\":117,\"70\":105,\"71\":122,\"72\":69,\"73\":115,\"74\":99,\"75\":114,\"76\":111,\"77\":119,\"78\":58,\"79\":32,\"80\":73,\"81\":110,\"82\":115,\"83\":117,\"84\":102,\"85\":102,\"86\":105,\"87\":99,\"88\":105,\"89\":101,\"90\":110,\"91\":116,\"92\":32,\"93\":102,\"94\":117,\"95\":110,\"96\":100,\"97\":115,\"98\":32,\"99\":102,\"100\":111,\"101\":114,\"102\":32,\"103\":112,\"104\":97,\"105\":121,\"106\":111,\"107\":117,\"108\":116,\"109\":0,\"110\":0,\"111\":0,\"112\":0,\"113\":0,\"114\":0,\"115\":0,\"116\":0,\"117\":0,\"118\":0,\"119\":0,\"120\":0,\"121\":0,\"122\":0,\"123\":0,\"124\":0,\"125\":0,\"126\":0,\"127\":0,\"128\":0,\"129\":0,\"130\":0,\"131\":0},\"sourceReference\":{\"sourceName\":\"contracts/src/QuizEscrow.sol\",\"sourceContent\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title QuizEscrow\\n * @dev A minimal payment processor and stats tracker for Discord quiz games\\n * @notice Only authorized Discord bot can record quiz results to prevent cheating\\n * @notice Quiz expires after 24 hours and returns unclaimed funds to creator\\n */\\ncontract QuizEscrow {\\n    // ============ IMMUTABLE STATE ============\\n    \\n    /// @notice Address of the quiz creator who funded this quiz\\n    address public immutable creator;\\n    \\n    /// @notice Address of the authorized Discord bot (only address that can record results)\\n    address public immutable authorizedBot;\\n    \\n    /// @notice Timestamp when this quiz contract was created\\n    uint256 public immutable creationTime;\\n    \\n    /// @notice Total amount of ETH funded for this quiz\\n    uint256 public immutable fundingAmount;\\n    \\n    /// @notice Reward amount paid for each correct answer\\n    uint256 public immutable correctReward;\\n    \\n    /// @notice Reward amount paid for each incorrect answer\\n    uint256 public immutable incorrectReward;\\n    \\n    // ============ MUTABLE STATE ============\\n    \\n    /// @notice Total amount paid out to participants\\n    uint256 public totalPaidOut;\\n    \\n    /// @notice Whether the quiz has been manually ended\\n    bool public isEnded;\\n    \\n    /// @notice Global stats: total number of participants\\n    uint256 public totalParticipants;\\n    \\n    /// @notice Global stats: total correct answers across all participants\\n    uint256 public totalCorrectAnswers;\\n    \\n    /// @notice Global stats: total incorrect answers across all participants  \\n    uint256 public totalIncorrectAnswers;\\n    \\n    /// @notice Array of participant addresses for iteration\\n    address[] public participantsList;\\n    \\n    /// @notice Mapping to track each participant's results and payments\\n    mapping(address => ParticipantResult) public participantResults;\\n    \\n    // ============ STRUCTS ============\\n    \\n    struct ParticipantResult {\\n        uint256 correctCount;      // Number of correct answers\\n        uint256 incorrectCount;    // Number of incorrect answers\\n        uint256 totalPayout;       // Total ETH paid to this participant\\n        bool hasParticipated;      // Whether this address has participated\\n    }\\n    \\n    // ============ EVENTS ============\\n    \\n    event QuizCreated(\\n        address indexed creator,\\n        address indexed authorizedBot,\\n        uint256 fundingAmount,\\n        uint256 correctReward,\\n        uint256 incorrectReward\\n    );\\n    \\n    event QuizResultRecorded(\\n        address indexed participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount,\\n        uint256 payout\\n    );\\n    \\n    event QuizEnded(uint256 totalParticipants, uint256 totalPaidOut);\\n    \\n    event UnclaimedFundsReturned(address indexed creator, uint256 amount);\\n    \\n    // ============ MODIFIERS ============\\n    \\n    modifier onlyAuthorizedBot() {\\n        require(msg.sender == authorizedBot, \\\"QuizEscrow: Only authorized bot can call this function\\\");\\n        _;\\n    }\\n    \\n    modifier quizNotEnded() {\\n        require(!isEnded, \\\"QuizEscrow: Quiz has ended\\\");\\n        require(block.timestamp < creationTime + 24 hours, \\\"QuizEscrow: Quiz has expired\\\");\\n        _;\\n    }\\n    \\n    // ============ CONSTRUCTOR ============\\n    \\n    /**\\n     * @notice Create a new quiz escrow contract\\n     * @param _creator Address of the quiz creator\\n     * @param _authorizedBot Address of the Discord bot authorized to record results\\n     * @param _correctReward Amount of ETH to pay for each correct answer\\n     * @param _incorrectReward Amount of ETH to pay for each incorrect answer\\n     */\\n    constructor(\\n        address _creator,\\n        address _authorizedBot,\\n        uint256 _correctReward,\\n        uint256 _incorrectReward\\n    ) payable {\\n        require(_creator != address(0), \\\"QuizEscrow: Invalid creator address\\\");\\n        require(_authorizedBot != address(0), \\\"QuizEscrow: Invalid bot address\\\");\\n        require(msg.value > 0, \\\"QuizEscrow: Must provide funding\\\");\\n        require(_correctReward > 0 || _incorrectReward > 0, \\\"QuizEscrow: Must provide non-zero rewards\\\");\\n        \\n        creator = _creator;\\n        authorizedBot = _authorizedBot;\\n        creationTime = block.timestamp;\\n        fundingAmount = msg.value;\\n        correctReward = _correctReward;\\n        incorrectReward = _incorrectReward;\\n        \\n        emit QuizCreated(_creator, _authorizedBot, msg.value, _correctReward, _incorrectReward);\\n    }\\n    \\n    // ============ CORE FUNCTIONS ============\\n    \\n    /**\\n     * @notice Record quiz results for a participant and pay rewards immediately\\n     * @dev Only callable by authorized bot to prevent cheating\\n     * @param participant Address of the quiz participant\\n     * @param correctCount Number of correct answers by participant\\n     * @param incorrectCount Number of incorrect answers by participant\\n     */\\n    function recordQuizResult(\\n        address participant,\\n        uint256 correctCount,\\n        uint256 incorrectCount\\n    ) external onlyAuthorizedBot quizNotEnded {\\n        require(participant != address(0), \\\"QuizEscrow: Invalid participant address\\\");\\n        require(!participantResults[participant].hasParticipated, \\\"QuizEscrow: Participant already recorded\\\");\\n        require(correctCount > 0 || incorrectCount > 0, \\\"QuizEscrow: Must have at least one answer\\\");\\n        \\n        // Calculate payout\\n        uint256 payout = (correctCount * correctReward) + (incorrectCount * incorrectReward);\\n        require(payout <= address(this).balance, \\\"QuizEscrow: Insufficient funds for payout\\\");\\n        \\n        // Record participant results\\n        participantResults[participant] = ParticipantResult({\\n            correctCount: correctCount,\\n            incorrectCount: incorrectCount,\\n            totalPayout: payout,\\n            hasParticipated: true\\n        });\\n        \\n        // Add to participants list\\n        participantsList.push(participant);\\n        \\n        // Update global stats\\n        totalParticipants++;\\n        totalCorrectAnswers += correctCount;\\n        totalIncorrectAnswers += incorrectCount;\\n        totalPaidOut += payout;\\n        \\n        // Pay participant immediately\\n        if (payout > 0) {\\n            (bool success, ) = participant.call{value: payout}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Payment failed\\\");\\n        }\\n        \\n        emit QuizResultRecorded(participant, correctCount, incorrectCount, payout);\\n    }\\n    \\n    /**\\n     * @notice Manually end the quiz and return unclaimed funds to creator\\n     * @dev Can be called after 24 hours or by authorized bot anytime\\n     */\\n    function endQuiz() external {\\n        require(\\n            block.timestamp >= creationTime + 24 hours || msg.sender == authorizedBot,\\n            \\\"QuizEscrow: Quiz not expired and caller not authorized bot\\\"\\n        );\\n        require(!isEnded, \\\"QuizEscrow: Quiz already ended\\\");\\n        \\n        isEnded = true;\\n        \\n        // Return unclaimed funds to creator\\n        uint256 remainingBalance = address(this).balance;\\n        if (remainingBalance > 0) {\\n            (bool success, ) = creator.call{value: remainingBalance}(\\\"\\\");\\n            require(success, \\\"QuizEscrow: Failed to return funds to creator\\\");\\n            \\n            emit UnclaimedFundsReturned(creator, remainingBalance);\\n        }\\n        \\n        emit QuizEnded(totalParticipants, totalPaidOut);\\n    }\\n    \\n    // ============ VIEW FUNCTIONS ============\\n    \\n    /**\\n     * @notice Get detailed results for a specific participant\\n     * @param participant Address of the participant\\n     * @return result Struct containing participant's quiz results and payout\\n     */\\n    function getParticipantResult(address participant) external view returns (ParticipantResult memory result) {\\n        return participantResults[participant];\\n    }\\n    \\n    /**\\n     * @notice Get overall quiz statistics\\n     * @return _totalParticipants Total number of participants\\n     * @return _totalCorrectAnswers Total correct answers across all participants\\n     * @return _totalIncorrectAnswers Total incorrect answers across all participants\\n     * @return _totalPaidOut Total amount paid out\\n     * @return _remainingBalance Remaining balance available for payouts\\n     * @return _isExpired Whether the 24-hour period has passed\\n     * @return _isEnded Whether the quiz has been manually ended\\n     */\\n    function getQuizStats() external view returns (\\n        uint256 _totalParticipants,\\n        uint256 _totalCorrectAnswers,\\n        uint256 _totalIncorrectAnswers,\\n        uint256 _totalPaidOut,\\n        uint256 _remainingBalance,\\n        bool _isExpired,\\n        bool _isEnded\\n    ) {\\n        return (\\n            totalParticipants,\\n            totalCorrectAnswers,\\n            totalIncorrectAnswers,\\n            totalPaidOut,\\n            address(this).balance,\\n            block.timestamp >= creationTime + 24 hours,\\n            isEnded\\n        );\\n    }\\n    \\n    /**\\n     * @notice Get remaining time before quiz expires (in seconds)\\n     * @return remainingTime Seconds until expiry, 0 if already expired\\n     */\\n    function getRemainingTime() external view returns (uint256 remainingTime) {\\n        uint256 expiryTime = creationTime + 24 hours;\\n        if (block.timestamp >= expiryTime) {\\n            return 0;\\n        }\\n        return expiryTime - block.timestamp;\\n    }\\n    \\n    /**\\n     * @notice Get all participant addresses\\n     * @return participants Array of all participant addresses\\n     */\\n    function getAllParticipants() external view returns (address[] memory participants) {\\n        return participantsList;\\n    }\\n    \\n    /**\\n     * @notice Get the current balance available for payouts\\n     * @return balance Current contract balance in wei\\n     */\\n    function getBalance() external view returns (uint256 balance) {\\n        return address(this).balance;\\n    }\\n}\\n\",\"contract\":\"QuizEscrow\",\"function\":\"onlyAuthorizedBot\",\"line\":87,\"range\":[2942,3036]},\"isInvalidOpcodeError\":false}],\"data\":\"0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000295175697a457363726f773a20496e73756666696369656e742066756e647320666f72207061796f75740000000000000000000000000000000000000000000000\",\"transactionHash\":\"0x6d8a82ba119590a836c69492aa2e0a9f7addd5cdb341f2504077d62b0d7f97c5\"}, method=\"sendTransaction\", transaction=undefined, code=INSUFFICIENT_FUNDS, version=providers/5.7.2)"
            },
            {
              "answerId": "answer_1750455925610_lkepyl096",
              "userAddress": "0x71bE63f3384f5fb98995898A86B02Fb2426c5788",
              "transactionHash": "0xd80ebe1324d27e36dca1e378caa2f19624e430c39aa76ca45cab095cbe0d9e3c",
              "gasUsed": {
                "type": "BigNumber",
                "hex": "0x024a16"
              }
            }
          ],
          "verification": {
            "simulation": {
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "escrowAddress": "0xB1eDe3F5AC8654124Cb5124aDf0Fd3885CbDD1F7",
              "participants": 10,
              "answers": 10
            },
            "database": {
              "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
              "totalParticipants": 0,
              "correctAnswers": 0,
              "incorrectAnswers": 0,
              "onChainAnswers": 0,
              "quiz": {
                "id": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
                "quizId": "5e67f5d6-4472-45a6-afa5-feb6430ad122",
                "creatorDiscordId": "123456789012345678",
                "creatorWalletAddress": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
                "sourceUrl": "https://simulation.example.com/quiz",
                "difficulty": "medium",
                "questionCount": 1,
                "tokenAddress": "0x0000000000000000000000000000000000000000",
                "chainId": 31337,
                "rewardAmount": "200000000000000000",
                "contractAddress": null,
                "status": "active",
                "createdAt": "2025-06-20T21:45:24.695Z",
                "participants": [],
                "escrowAddress": "0xB1eDe3F5AC8654124Cb5124aDf0Fd3885CbDD1F7",
                "transactionHash": "0x4d42b47b3bfc447a471ba773b8e15dde2d679087158c40d6f64fffc96f192946",
                "onChain": true,
                "expiryTime": 1750542324,
                "fundingStatus": "funded"
              },
              "answers": []
            },
            "contract": {
              "creator": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
              "correctReward": "0.15",
              "incorrectReward": "0.05",
              "fundingAmount": "0.199",
              "remainingBalance": "0.049",
              "totalCorrectAnswers": "0",
              "totalIncorrectAnswers": "3",
              "totalParticipants": "3",
              "totalPaidOut": "0.15",
              "creationTime": "2025-06-20T21:45:35.000Z",
              "isEnded": false
            },
            "verification": {
              "databaseContractSync": false,
              "allAnswersOnChain": true,
              "balanceCalculation": "verified"
            }
          }
        }
      },
      "duration": 1069
    }
  ],
  "performance": {
    "averageDuration": 817,
    "fastest": 565,
    "slowest": 1069
  },
  "readiness": {
    "contractDeployment": true,
    "databaseIntegration": false,
    "userSimulation": true,
    "blockchainRecording": true,
    "overallReadiness": true
  }
}